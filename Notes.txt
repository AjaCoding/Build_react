Building my own React.js. 
A declarative UI framework with virtual DOM reconciliation and hook-based state management. 

project review: 
Architecture diagram

Performance comparisons

Design tradeoffs

â€œWhat Iâ€™d do differently nextâ€

Phase 0: 
Skills to be comfortable with

JavaScript (ES6+)

Closures, immutability

DOM APIs

Functional programming basics

Data structures (trees)

Key ideas to review

How the browser renders DOM

Why DOM updates are expensive

Why frameworks exist

ğŸ“Œ Deliverable: You can manually create and update 
    DOM nodes and understand why batching matters.

Phase 1: Create a Minimal Renderer (Week 1)
Goal

Render UI from plain JS objects instead of HTML.
Tasks

Define a createElement function

Convert object â†’ real DOM

Append to root container

Skills learned

Declarative UI

Tree traversal

DOM manipulation

ğŸ“Œ Milestone: You can render a static UI without touching HTML.

Phase 2: Components & Composition (Week 2)
Goal

Support functions as components
like: function Hello(props) {
  return createElement("h1", {}, `Hello ${props.name}`);
}

Tasks

Detect when type is a function

Call it to produce child elements

Allow nested components

Concepts

Component trees

Pure functions

Props

ğŸ“Œ Milestone: Components can call components.

Notes: Functions take in props as their argument(s) and usually it is only one var passed in. 
The render function executes in a depth-first order. Rendering the main element, then it's children.
Rule: render() always takes a VDOM element. createElement() wraps a function component. different purposes. 
There is exactly one root element, so all elements need to be contained in it for rendering. 
We have arrived at pre-hooks React now. 
1/6: Today we added completed functions and events. We now have a working Count object element that can be re-used 
across the site and successfuly incremenets across states. Next, I incremented states! This is purely index bookeeping 
to ensure that the right variables are kept concurrent across states even when modified. This design helps to work 
towards reconciliation, which uses the separated concerns: rendering, state storage, and state change. 
At this point, we are nearly at a full basic React duplcation in our own fashion. We are able to dynamically
make any html element, and even have a handler for onclick of a button element that updates another(an event!). 
We render and update(re-render + states handling). 

Before moving on: 
1. Two useState calls in one component 
2. Two Counter components on the page
3. Logging hookStates each render 
4. Breakign hook order intentionally and watching failure. 
----> earned reconciliation

Phase 3: Virtual DOM & Diffing (Weeks 3â€“4)
Goal

Update only what changed.

Tasks

Store previous virtual tree

Compare old vs new tree

Generate minimal DOM operations

Diffing basics

Same node type â†’ update props

Different type â†’ replace node

Recurse on children

Skills learned

Tree diff algorithms

Performance optimization

Structural sharing

ğŸ“Œ This alone is already a strong portfolio project

Phase 4: State Management (Weeks 5â€“6)
Goal

Allow components to re-render based on state changes.

Minimal API
const [count, setCount] = useState(0);

Start simpler:

Global state store

Component-local state map

Re-render entire tree on state change

Then improve:

Only re-render affected subtree

Preserve state between renders

Concepts

Closures

Referential identity

Render scheduling

ğŸ“Œ Milestone: Clicking a button updates the UI declaratively.

Phase 5: Event System (Week 7)
Goal

Handle events efficiently.

Tasks

Attach event handlers via props

Normalize events

Optional: event delegation

Skills learned

Browser event model

Synthetic events

Memory optimization

Phase 6: Hooks & Lifecycle (Weeks 8â€“9)
Goal

Generalize state and effects.

Implement:

useState

useEffect (basic)

Dependency tracking

Concepts

Call order invariants

Side-effect scheduling

Cleanup handling

ğŸ“Œ This is where things feel â€œReact-ishâ€

Phase 7: JSX (Optional, Weeks 10â€“11)
Goal

Developer ergonomics.

Tasks

Use Babel to transform JSX â†’ createElement

Build your own JSX pragma

/** @jsx MyReact.createElement */

Skills learned

Tooling

AST transforms

Build pipelines

Phase 8: Performance and Architecture (optional improvement)

